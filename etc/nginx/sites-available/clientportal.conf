# example.com — IBKR reverse proxy
#
# Backends:
#   gateway  (localhost:5001) — IBKR REST API proxy
#   feed     (localhost:5002) — WebSocket multiplexer
#
# Route summary:
#   /v1/api/ws                     → 403 (use /ws instead)
#   /v1/api/iserver/secdef/search  → rate-limited, cached 1d → gateway
#   /v1/api/                       → rate-limited → gateway
#   /ws                            → WebSocket → feed
#   /gateway/health                → public → gateway /health
#   /feed/health                   → public → feed /health
#   /session                       → basic auth → gateway
#   /status                        → basic auth → feed
#   /                              → basic auth → gateway
#   (everything else)              → gateway (returns 404 for unknown paths)

server {
    listen [::]:443 ssl http2 ipv6only=on;
    listen 443 ssl http2;

    ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    server_name example.com;

    # Security headers at server level — applies to all locations that have no
    # add_header of their own (most locations). Cache snippet locations must
    # include this file explicitly inside the snippet (already done).
    include /etc/nginx/snippets/security-headers.conf;

    # ------------------------------------------------------------------
    # Block direct IBKR WebSocket. Clients must use /ws (Feed service).
    # Feed manages auth, reconnect, and fan-out; browsers don't need their
    # own IBKR session. Exact match has higher priority than /v1/api/ prefix.
    # ------------------------------------------------------------------
    location = /v1/api/ws {
        return 403 "Direct WebSocket connections are not allowed. Use /ws instead.\n";
    }

    # ------------------------------------------------------------------
    # Cacheable API: instrument definition search.
    # Symbol→conid mappings are stable within a day. Caching avoids
    # repeated IBKR API calls for the same symbol lookups.
    # ------------------------------------------------------------------
    location ~ ^/v1/api/iserver/secdef/search$ {
        include /etc/nginx/snippets/cache1d.conf;
        include /etc/nginx/snippets/ratelimit.conf;
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://gateway;
    }

    # ------------------------------------------------------------------
    # All IBKR REST API routes.
    # Rate-limited to respect IBKR's 10 r/s server-side limit.
    # ------------------------------------------------------------------
    location /v1/api/ {
        include /etc/nginx/snippets/ratelimit.conf;
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://gateway;
    }

    # ------------------------------------------------------------------
    # Browser WebSocket — Feed multiplexer.
    # Long-lived connections; 1h timeouts. proxy_buffering off streams
    # WebSocket frames immediately without accumulation.
    # Cannot use clientportal.conf snippet: WS needs Upgrade/Connection
    # headers and longer timeouts than HTTP requests.
    # ------------------------------------------------------------------
    location /ws {
        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;    # Required for WS handshake
        proxy_set_header Connection          $connection_upgrade; # "upgrade" or "close" per websockets.conf
        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;
        proxy_read_timeout  1h;   # WebSocket connections are long-lived and idle between ticks
        proxy_send_timeout  1h;
        proxy_buffering off;      # Must stream frames immediately, not buffer them
        proxy_pass http://feed;
    }

    # ------------------------------------------------------------------
    # Public health checks — no auth, for monitoring tools.
    # proxy_pass with URI path rewrites: /gateway/health → upstream gets /health.
    # (nginx strips the matched location and appends remainder to proxy_pass URI)
    # ------------------------------------------------------------------
    location = /gateway/health {
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://gateway/health;
    }

    location = /feed/health {
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://feed/health;
    }

    # ------------------------------------------------------------------
    # Protected internal endpoints — basic auth required.
    # /session  — Gateway JSON session state (tokens, auth status). Sensitive.
    # /status   — Feed status page (subscription counts, upstream state).
    # /         — Gateway Razor Pages status page.
    # ------------------------------------------------------------------
    location = /session {
        auth_basic           "Restricted";
        auth_basic_user_file /etc/nginx/.htpasswd;
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://gateway;
    }

    location = /status {
        auth_basic           "Restricted";
        auth_basic_user_file /etc/nginx/.htpasswd;
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://feed;
    }

    location = / {
        auth_basic           "Restricted";
        auth_basic_user_file /etc/nginx/.htpasswd;
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://gateway;
    }

    # ------------------------------------------------------------------
    # Catch-all: everything else goes to gateway.
    # Gateway returns 404 for paths it doesn't recognise. This covers
    # static assets linked from the status page and any other paths.
    # ------------------------------------------------------------------
    location / {
        include /etc/nginx/snippets/clientportal.conf;
        proxy_pass http://gateway;
    }
}

# HTTP → HTTPS redirect.
server {
    listen 80;
    listen [::]:80;
    server_name example.com;

    if ($host = example.com) {
        return 301 https://$host$request_uri;
    }

    return 404;
}
